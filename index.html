<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Exercice 2 – Grab & Release</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- A-Frame 1.7.0 -->
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <!-- A-Frame 1.5+ : éviter le conflit de nom "grabbable" -->
    <script> delete AFRAME.components["grabbable"]; </script> <!-- cf. super-hands -->

    <!-- aframe-extras (sphere-collider) -->
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

    <!-- Physics system (CANNON/Ammo support) -->
    <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>

    <!-- super-hands 3.x -->
    <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>

    <!-- Tes composants de déplacement -->
    <script>
      // Déplacement joystick gauche
      AFRAME.registerComponent('joystick-movement', {
        schema: { speed: { type: 'number', default: 2 } },
        init: function () {
          const rig = document.querySelector('#rig');
          const head = document.querySelector('#head');
          const leftHand = document.querySelector('#leftHand');
          const speed = this.data.speed;
          const DEADZONE = 0.1;

          leftHand.addEventListener('thumbstickmoved', function (evt) {
            const dx = evt.detail.x, dy = evt.detail.y;
            if (Math.abs(dx) < DEADZONE && Math.abs(dy) < DEADZONE) return;

            const forward = new THREE.Vector3();
            head.object3D.getWorldDirection(forward);
            forward.y = 0; forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).negate();

            const step = 0.05 * speed;
            const rigPos = rig.object3D.position;
            rigPos.addScaledVector(forward, dy * step);
            rigPos.addScaledVector(right,  dx * step);
          });
        }
      });

      // Rotation par crans (joystick droit)
      AFRAME.registerComponent('snap-turn', {
        schema: { angle: { type: 'number', default: 30 }, cooldown: { type: 'number', default: 300 } },
        init: function () {
          const rig = document.querySelector('#rig');
          const rightHand = document.querySelector('#rightHand');
          const angle = this.data.angle, cooldown = this.data.cooldown;
          let lastTurn = 0;
          rightHand.addEventListener('thumbstickmoved', function (evt) {
            const now = Date.now(), x = evt.detail.x;
            if (Math.abs(x) < 0.8 || now - lastTurn < cooldown) return;
            const rad = THREE.MathUtils.degToRad(angle);
            if (x > 0.8)  rig.object3D.rotation.y -= rad;
            else          rig.object3D.rotation.y += rad;
            lastTurn = now;
          });
        }
      });
    
    // Gun Shooting
    AFRAME.registerComponent('gun-shoot', {
      schema: {
        hand: { type: 'selector' },    
        bulletSpeed: { type: 'number', default: 40 }
      },
      init: function () {
        const el = this.el;
        const hand = this.data.hand;
        const speed = this.data.bulletSpeed;
        let lastShot = 0;
        const cooldown = 300;

        // Ajouter un son de tir au pistolet
        this.shootSound = document.createElement('a-entity');
        this.shootSound.setAttribute('sound', 'src: #shootSound; autoplay: false; volume: 1');
        el.appendChild(this.shootSound);

        // Récupérer la position de tir
        const shootPos = el.querySelector('#shootPos');

        hand.addEventListener('triggerdown', () => {

          const now = Date.now();
          if (!el.is('grabbed')) return; // Tir seulement si le gun est en main
          if (now - lastShot < cooldown) return; // bloque si délai pas écoulé
          lastShot = now;

          // Jouer le son
          this.shootSound.components.sound.stopSound(); // remet à zéro si spam
          this.shootSound.components.sound.playSound();

          // Créer la balle
          const bullet = document.createElement('a-sphere');
          bullet.classList.add('bullet');

          // Positionner la balle sur shootPos
          const startPos = shootPos.object3D.getWorldPosition(new THREE.Vector3());
          bullet.setAttribute('position', startPos);
          bullet.setAttribute('radius', 0.05);
          bullet.setAttribute('color', '#F00');

          // Ajouter le corps physique
          bullet.setAttribute('dynamic-body', `mass: 0.1; shape: sphere`);

          // Ajouter la balle à la scène
          el.sceneEl.appendChild(bullet);

          // Calculer la direction vers l'avant de shootPos
          const direction = new THREE.Vector3(0, 0, -1); // Avant local
          shootPos.object3D.getWorldQuaternion(new THREE.Quaternion())
            .multiply(new THREE.Quaternion())
            .setFromAxisAngle(new THREE.Vector3(0,0,0),0); // pas nécessaire mais peut garder pour ajuster

          shootPos.object3D.getWorldQuaternion(new THREE.Quaternion()).multiply(direction); // inutile ici

          shootPos.object3D.getWorldDirection(direction); // récupère la direction avant correctement
          direction.normalize();

          // Appliquer la vitesse initiale via A-Frame Physics
          bullet.addEventListener('body-loaded', () => {
            bullet.setAttribute('velocity', `${direction.x * speed} ${direction.y * speed} ${direction.z * speed}`);
          });

          // Supprimer la balle après 5 secondes
          setTimeout(() => { bullet.remove(); }, 5000);
        });
      }
    });

    // Destruction des objets
    AFRAME.registerComponent('destructible', {
      init: function () {
        const el = this.el;
        el.addEventListener('collide', function (e) {
          const other = e.detail.body.el;
          // On ne réagit qu'aux balles
          if (!other || !other.classList.contains('bullet')) return;

          // Jouer un son au point d'impact
          const sound = document.createElement('a-entity');
          sound.setAttribute('sound', `src: #hitSound; autoplay: true`);
          sound.object3D.position.copy(el.object3D.position);
          el.sceneEl.appendChild(sound);

          // Supprimer l'objet après 200ms
          setTimeout(()=> el.parentNode && el.parentNode.removeChild(el),200);

          // Supprimer la balle aussi (optionnel)
          setTimeout(()=> other.parentNode && other.parentNode.removeChild(other),100);
        });
      }
    });

    // --- SPAWN DE CUBES ALÉATOIRES ---
    AFRAME.registerComponent('cube-spawner', {
      schema: {
        interval: { type: 'number', default: 2000 }, // délai entre spawns en ms
        range:    { type: 'number', default: 10 }    // zone aléatoire X/Z
      },
      init: function () {
        const scene = this.el;
        const interval = this.data.interval;
        const range = this.data.range;

        setInterval(() => {
          // taille aléatoire (0.5 → 2.0)
          const size = THREE.MathUtils.randFloat(0.5, 2);

          // position aléatoire (X et Z dans [-range, +range])
          const posX = THREE.MathUtils.randFloatSpread(range * 2); // -range à +range
          const posZ = THREE.MathUtils.randFloatSpread(range * 2);

          // rotation aléatoire
          const rotY = THREE.MathUtils.randFloat(0, 180);
          const rotX = THREE.MathUtils.randFloat(0, 180);
          const rotZ = THREE.MathUtils.randFloat(0, 180);

          // créer le cube
          const cube = document.createElement('a-box');
          cube.setAttribute('position', `${posX} 5 ${posZ}`);
          cube.setAttribute('rotation', `${rotX} ${rotY} ${rotZ}`);
          cube.setAttribute('scale', `${size} ${size} ${size}`);
          cube.setAttribute('color', '#'+Math.floor(Math.random()*16777215).toString(16)); // couleur aléatoire
          cube.setAttribute('shadow', 'cast: true; receive: true');
          cube.setAttribute('grabbable', 'usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend');
          cube.setAttribute('dynamic-body', 'mass: 1; shape: box');
          cube.setAttribute('destructible', '');

          scene.appendChild(cube);
        }, interval);
      }
    });

    </script>
  </head>

  <body>
    <a-scene
      shadow="type: pcfsoft"
      renderer="antialias: true"
      vr-mode-ui="enabled: true"
      device-orientation-permission-ui="enabled: true"
      physics="gravity: -9.8; debug: false"
      cube-spawner="interval: 3000; range: 10"
    >
      <!-- Assets -->
      <a-assets>
        <img id="skyTexture" src="assets/sky.png" />
        <img id="groundTexture" src="assets/ground.jpg" />
        <a-asset-item id="gun" src="assets/sci_fi_gun_model.glb"></a-asset-item>
        <audio id="hitSound" src="assets/bulletHit.mp3"></audio>
        <audio id="shootSound" src="assets/gunshot.mp3"></audio>
      </a-assets>

      <!-- Lumières -->
      <a-entity light="type: ambient; intensity: 0.4"></a-entity>
      <a-entity light="type: directional; intensity: 1; castShadow: true" position="2 4 -2"></a-entity>

      <!-- RIG + caméra + contrôleurs -->
      <a-entity id="rig" position="0.77334 0.16159 4.0298" joystick-movement="speed: 2" snap-turn="angle: 30; cooldown: 300">
        <a-entity id="head" camera wasd-controls-enabled="false" look-controls></a-entity>

        <!-- Mains : super-hands limité au bouton grip (side) + collision par sphère -->
        <a-entity id="leftHand"
          oculus-touch-controls="hand: left"
          super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
          sphere-collider="objects: .grabbable"
          static-body="shape: sphere; sphereRadius: 0.03">
        </a-entity>

        <a-entity id="rightHand"
          oculus-touch-controls="hand: right"
          super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
          sphere-collider="objects: .grabbable"
          static-body="shape: sphere; sphereRadius: 0.03">
        </a-entity>
      </a-entity>

      <!-- OBJETS SAISISSABLES (physiques) -->
      <a-box id="box" class="grabbable" position="-5.19013 1.19381 0.75354" rotation="0 45 20" color="#4CC3D9"
             shadow="cast: true; receive: true"
             grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
             dynamic-body="mass: 1; shape: box"
             destructible>
      </a-box>

      <a-box id="box1" class="grabbable" position="-2.16439 2.48242 0" rotation="0 45 0" color="#4CC3D9"
             shadow="cast: true; receive: true"
             grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
             dynamic-body="mass: 1; shape: box"
             destructible>
      </a-box>

      <a-box id="box2" class="grabbable" position="-5.91639 4.85571 -6.3178" rotation="0 45 0" color="#4CC3D9"
             shadow="cast: true; receive: true"
             grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
             dynamic-body="mass: 1; shape: box"
             destructible>
      </a-box>

      <a-entity id="GunWrapper" rotation="0 0 0" scale="1.5 1.5 1.5"
        position="2.53101 3.10454 0.06401"
        class="grabbable"
        shadow="cast: true; receive: true"
        geometry="primitive: box; width: 0.3; height: 0.15; depth: 0.05"
        material="opacity: 0; transparent: true"
        visible="true"
        grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
        dynamic-body="mass: 1; shape: box"
        gun-shoot="hand: #rightHand;">

        <a-entity id="gunModel" position="0.08905 0.00241 -0.00122"
          gltf-model="#gun"
          scale="0.1 0.1 0.1"
          shadow="cast: true; receive: true">

          <a-entity id="shootPos" rotation="0 -90 0" position="-2.40375 0.68138 0"></a-entity>
        </a-entity>
      </a-entity>

      <!-- Sol -->
      <a-plane position="0 0 -1" rotation="-90 0 0" width="100" height="100" src="#groundTexture"
               shadow="cast: false; receive: true"
               static-body>
      </a-plane>

      <a-sky src="#skyTexture"></a-sky>
    </a-scene>
  </body>
</html>